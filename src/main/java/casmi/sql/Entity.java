/*
 *   casmi
 *   http://casmi.github.com/
 *   Copyright (C) 2011, Xcoo, Inc.
 *
 *  casmi is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package casmi.sql;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.sql.Blob;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import casmi.sql.annotation.Fieldname;
import casmi.sql.annotation.Ignore;
import casmi.sql.annotation.Tablename;

/**
 * An entity class expressing a table in a database.
 *
 * <p>
 * This class is used for an Active Record function in casmi.
 * Defines an original class that extends this Entity class.
 * </p>
 * 
 * <p>
 * Example:
 * <pre><code>
 *     import casmi.sql.Entity;
 *     import casmi.sql.annotation.Fieldname;
 *     import casmi.sql.annotation.Ignore;
 * 
 *     public class MyEntity extends Entity {
 *     
 *         public  String text;
 *         
 *         @Fieldname(NUM_1)
 *         private int    num1;
 *         
 *         public  double num2;
 *         
 *         @Ignore
 *         public  float  num3;
 *         
 *         public int getNum1() {
 *             return num1;
 *         }
 *         
 *         public void setNum1(int num1) {
 *             this.num1 = num1;
 *         }
 *     }
 * </code></pre>
 * </p>
 * 
 * @see casmi.sql.SQLite
 * @see casmi.sql.MySQL
 * @see casmi.sql.Query
 * @see casmi.sql.annotation.Fieldname
 * @see casmi.sql.annotation.Ignore
 * @see casmi.sql.annotation.PrimaryKey
 * @see casmi.sql.annotation.Tablename
 * 
 * @author T. Takeuchi
 */
abstract public class Entity {

    /** A table name. */
    private String tablename;
    
    private SQL sql;

    private Class<? extends Entity> type;

    /** A primary key automatically generated by a program. */
    private int id = -1;

    /** Columns. */
    private Column[] columns;
    
    final <T extends Entity> void init(SQL sql, Class<T> type) {

        this.sql  = sql;
        this.type = type;

        tablename = getTablename(type);
        try {
            columns = fieldsToColumns();
            if (!existTable()) {
                createTable();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private final boolean existTable() throws SQLException {

        DatabaseMetaData dmd = sql.getConnection().getMetaData();
        ResultSet rs = dmd.getTables(null, null, null, null);
        while (rs.next()) {
            if (tablename.equals(rs.getString("TABLE_NAME"))) {
                return true;
            }
        }
        return false;
    }

    private final void createTable() throws SQLException {

        StringBuilder sb = new StringBuilder();
        sb.append("id ");
        sb.append(StatementGenerator.type(sql.getSQLType(), int.class));
        sb.append(" PRIMARY KEY ");
        switch (sql.getSQLType()) {
        case SQLITE_3:
            sb.append("AUTOINCREMENT");
            break;
        case MYSQL_5:
            sb.append("AUTO_INCREMENT");
            break;
        default:
            sb.append("AUTO_INCREMENT");
            break;
        }
        
        for (Column column : columns) {
            sb.append(',');
            sb.append(column.getField());
            sb.append(' ');
            sb.append(StatementGenerator.type(sql.getSQLType(), column.getType()));
        }
        
        String stmt = StatementGenerator.createTable(sql.getSQLType(), tablename, sb.toString());
        sql.execute(stmt);
    }

    public final void save() throws SQLException {

        columns = fieldsToColumns();

        if (id == -1) {
            insert();
        } else {
            update();
        }
    }

    private final void insert() throws SQLException {

        String sqlStr = StatementGenerator.insert(sql.getSQLType());

        sqlStr = sqlStr.replaceAll(":table", tablename);

        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        List<Object> list = new ArrayList<Object>();

        for (Column c : columns) {
            if (sb1.length() != 0) sb1.append(',');
            if (sb2.length() != 0) sb2.append(',');
            sb1.append(c.getField());
            sb2.append("?");
            list.add(c.getValue());
        }
        sqlStr = sqlStr.replaceAll(":fields", sb1.toString());
        sqlStr = sqlStr.replaceAll(":values", sb2.toString());

        sql.execute(sqlStr, list.toArray());
    }

    private final void update() throws SQLException {

        String sqlStr = StatementGenerator.update(sql.getSQLType());

        sqlStr = sqlStr.replaceAll(":table", tablename);

        StringBuilder sb = new StringBuilder();
        List<Object> list = new ArrayList<Object>();

        for (Column column : columns) {
            if (sb.length() != 0) sb.append(',');
            sb.append(column.getField());
            sb.append("=?");
            list.add(column.getValue());
        }
        list.add(id);
        sqlStr = sqlStr.replaceAll(":sets", sb.toString());
        
        sqlStr = sqlStr.replaceAll(":id", "?");

        sql.execute(sqlStr, list.toArray());
    }

    public final void delete() throws SQLException {

        if (id == -1) {
            throw new SQLException("This record has not been in a database yet.");
        }
        String stmt = StatementGenerator.delete(sql.getSQLType(), tablename, "id=" + id);
        sql.execute(stmt);
    }

    private final Column[] fieldsToColumns() throws SQLException {

        List<Column> list = new ArrayList<Column>();

        for (Field f : type.getDeclaredFields()) {
            Column c = null;
            
            try {
                String   name  = f.getName();
                String   field;
                Class<?> type  = f.getType();
                
                // "this$0" is a tacit field generated automatically if the class
                // is an inner class. 
                // It expresses a declared class object, so should be ignored.
                if (name.equals("this$0")) continue;
                
                if (f.getAnnotation(Ignore.class) != null) continue;
                
                Fieldname FieldnameAnnot = f.getAnnotation(Fieldname.class);
                if (FieldnameAnnot != null) {
                    field = FieldnameAnnot.value();
                } else {
                    field = name;
                }
                
                if (Modifier.isPublic(f.getModifiers())) {
                    // access directly
                    Object value = f.get(this);
                    if (value == null) {
                        c = new Column(name, field, null, type);
                    } else if (type.equals(int.class) ||
                               type.equals(Integer.class)) {
                        c = new Column(name, field, (Integer)value, type);
                    } else if (type.equals(short.class) ||
                               type.equals(Short.class)) {
                        c = new Column(name, field, (Short)value, type);
                    } else if (type.equals(long.class) ||
                               type.equals(Long.class)) {
                        c = new Column(name, field, (Long)value, type);
                    } else if (type.equals(String.class)) {
                        c = new Column(name, field, (String)value, type);
                    } else if (type.equals(double.class) ||
                               type.equals(Double.class)) {
                        c = new Column(name, field, (Double)value, type);
                    } else if (type.equals(float.class) ||
                               type.equals(Float.class)) {
                        c = new Column(name, field, (Float)value, type);
                    } else if (type.equals(Date.class)) {
                        c = new Column(name, field, (Date)value, type);
                    } else if (type.equals(Blob.class)) {
                        c = new Column(name, field, (Blob)value, type);
                    } else {
                        continue;
                    }
                } else {
                    // access using setter/getter
                    PropertyDescriptor pd = new PropertyDescriptor(name, this.type);
                    Method m = pd.getReadMethod();
                    Object value = m.invoke(this, (Object[])null);
                    if (value == null) {
                        c = new Column(name, field, null, type);
                    } else if (type.equals(int.class) ||
                               type.equals(Integer.class)) {
                        c = new Column(name, field, (Integer)value, type);
                    } else if (type.equals(short.class) ||
                               type.equals(Short.class)) {
                        c = new Column(name, field, (Short)value, type);
                    } else if (type.equals(long.class) ||
                               type.equals(Long.class)) {
                        c = new Column(name, field, (Long)value, type);
                    } else if (type.equals(String.class)) {
                        c = new Column(name, field, (String)value, type);
                    } else if (type.equals(double.class) ||
                               type.equals(Double.class)) {
                        c = new Column(name, field, (Double)value, type);
                    } else if (type.equals(float.class) ||
                               type.equals(Float.class)) {
                        c = new Column(name, field, (Float)value, type);
                    } else if (type.equals(Date.class)) {
                        c = new Column(name, field, (Date)value, type);
                    } else if (type.equals(Blob.class)) {
                        c = new Column(name, field, (Blob)value, type);
                    } else {
                        continue;
                    }
                }

                list.add(c);
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (IntrospectionException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            }
        }

        if (list.isEmpty()) {
            throw new SQLException("Fields are not validated.");
        }

        return list.toArray(new Column[list.size()]);
    }
    
    private final void columnsToFields() {
        
        for (Column c : columns) {
            try {
                Field f = this.type.getDeclaredField(c.getName());
                
                // "this$0" is a tacit field generated automatically if the class
                // is an inner class. 
                // It expresses a declared class object, so should be ignored.
                if (f.getName().equals("this$0")) continue;
                
                if (Modifier.isPublic(f.getModifiers())) {
                    f.set(this, c.getValue());
                } else {
                    PropertyDescriptor pd = new PropertyDescriptor(f.getName(), this.type);
                    Method m = pd.getWriteMethod();
                    m.invoke(this, c.getValue());
                }
            } catch (SecurityException e) {
                e.printStackTrace();
            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (IntrospectionException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            }
        }
    }
    
    final void setValuesFromResultSet(ResultSet resultSet) throws SQLException {
        
        id = sql.get(resultSet, int.class, "id");
        
        for (Column column : columns) {
            Object value = sql.get(resultSet, column.getType(), column.getField());
            column.setValue(value);
        }
        
        columnsToFields();
    }
    
    final void setValuesFromReslutSet(ResultSet resultSet, String... fields) 
        throws SQLException {
        
        id = sql.get(resultSet, int.class, "id");
        
        for (Column column : columns) {
            boolean flag = false;
            for (String field : fields) {
                if (column.getField().equals(field)) flag = true;
            }
            
            if (flag) {
                Object value = sql.get(resultSet, column.getType(), column.getField());
                column.setValue(value);
            }
        }
        
        columnsToFields();
    }
    
    @Override
    public String toString() {
    
        StringBuilder sb = new StringBuilder();
        sb.append(tablename);
        sb.append(" {id: ");
        sb.append(id);
        for (Column column : columns) {
            sb.append(", ");
            sb.append(column.getField());
            sb.append(": ");
            sb.append(column.getValue());
        }
        sb.append('}');
        
        return sb.toString();
    }
    
    static final <T extends Entity> String getTablename(Class<T> type) {        
        Tablename annotation = type.getAnnotation(Tablename.class);
        if (annotation != null) {
            return annotation.value();
        }
        
        return type.getSimpleName();
    }

    public String getTablename() {
        
        return tablename;
    }
    
    public int getID() {
        
        return id;
    }
}
